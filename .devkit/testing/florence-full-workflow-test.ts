#!/usr/bin/env bun

/**
 * FLORENCE FULL WORKFLOW TEST
 * 
 * Tests complete Florence manuscript workflow using production logic:
 * 1. URL Detection ‚Üí Library identification
 * 2. Routing ‚Üí FlorenceLoader invocation  
 * 3. Manifest Loading ‚Üí Page discovery with session management
 * 4. Download Simulation ‚Üí Test first few pages to validate accessibility
 * 5. Gap Detection ‚Üí Identify and handle 501 errors
 */

import { FlorenceLoader } from '../../src/main/services/library-loaders/FlorenceLoader';
import { SharedLibraryDetector } from '../../src/shared/SharedLibraryDetector';

// Mock dependencies for production-like testing
const mockLogger = {
    log: () => {},
    logDownloadStart: () => {},
    logDownloadComplete: () => {},
    logDownloadError: () => {}
};

const loaderDeps = {
    fetchWithHTTPS: fetch,
    fetchWithProxyFallback: fetch,
    fetchDirect: fetch,
    logger: mockLogger
};

async function testCompleteFlorencdWorkflow() {
    console.log('üèõÔ∏è FLORENCE COMPLETE WORKFLOW TEST');
    console.log('==================================\n');
    
    const testUrl = 'https://cdm21059.contentdm.oclc.org/digital/collection/plutei/id/217923/rec/2';
    console.log(`üéØ Target: ${testUrl}\n`);
    
    try {
        // Step 1: URL Detection (production logic)
        console.log('üìã Step 1: URL Detection...');
        const detector = new SharedLibraryDetector();
        const detectedLibrary = detector.detectLibrary(testUrl);
        console.log(`‚úÖ Detected library: "${detectedLibrary}"`);
        
        if (detectedLibrary !== 'florence') {
            throw new Error(`Expected 'florence', got '${detectedLibrary}'`);
        }
        
        // Step 2: Routing (production logic would route to FlorenceLoader)
        console.log('\nüìã Step 2: Routing to FlorenceLoader...');
        const florenceLoader = new FlorenceLoader(loaderDeps);
        console.log('‚úÖ FlorenceLoader instantiated');
        
        // Step 3: Manifest Loading (production FlorenceLoader logic)
        console.log('\nüìã Step 3: Loading manifest with production logic...');
        console.log('This includes:');
        console.log('- ContentDM session establishment (JSESSIONID)');
        console.log('- HTML parsing to extract __INITIAL_STATE__');
        console.log('- Child page ID extraction (not parent compound ID)');
        console.log('- Intelligent size determination (6000‚Üí4000‚Üí2048‚Üí1024‚Üí800px)');
        
        const startTime = Date.now();
        const manifest = await florenceLoader.loadManifest(testUrl);
        const manifestDuration = Date.now() - startTime;
        
        console.log(`‚úÖ Manifest loaded in ${manifestDuration}ms:`);
        console.log(`   - Library: ${manifest.library}`);
        console.log(`   - Display Name: ${manifest.displayName}`);
        console.log(`   - Total Pages: ${manifest.totalPages}`);
        console.log(`   - Page Links Generated: ${manifest.pageLinks?.length}`);
        
        // Step 4: Download Simulation (test actual page accessibility)
        console.log('\nüìã Step 4: Production Download Simulation...');
        console.log('Testing page accessibility with same headers as production...');
        
        if (!manifest.pageLinks || manifest.pageLinks.length === 0) {
            throw new Error('No page links generated by manifest loader');
        }
        
        // Test first 10 pages to validate production download would work
        const testPages = Math.min(10, manifest.pageLinks.length);
        console.log(`Testing first ${testPages} pages for download accessibility...\n`);
        
        let successCount = 0;
        let error501Count = 0;
        let otherErrorCount = 0;
        
        for (let i = 0; i < testPages; i++) {
            const pageUrl = manifest.pageLinks[i];
            const pageId = pageUrl.match(/plutei:(\d+)/)?.[1] || 'unknown';
            
            try {
                const response = await fetch(pageUrl, {
                    method: 'HEAD',
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
                        'Accept': 'image/*,*/*;q=0.8',
                        'Accept-Language': 'it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7',
                        'Referer': 'https://cdm21059.contentdm.oclc.org/',
                        'Sec-Fetch-Dest': 'image',
                        'Sec-Fetch-Mode': 'no-cors',
                        'Sec-Fetch-Site': 'same-origin',
                        'DNT': '1'
                    }
                });
                
                if (response.ok) {
                    successCount++;
                    const size = response.headers.get('content-length');
                    console.log(`‚úÖ Page ${i+1} (ID ${pageId}): ${response.status} ${size ? Math.round(parseInt(size)/1024) + 'KB' : 'unknown size'}`);
                } else if (response.status === 501) {
                    error501Count++;
                    console.log(`‚ö†Ô∏è  Page ${i+1} (ID ${pageId}): 501 Not Implemented (gap in sequence)`);
                } else {
                    otherErrorCount++;
                    console.log(`‚ùå Page ${i+1} (ID ${pageId}): ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                otherErrorCount++;
                console.log(`‚ùå Page ${i+1} (ID ${pageId}): ${error instanceof Error ? error.message : String(error)}`);
            }
            
            // Rate limiting like production
            await new Promise(resolve => setTimeout(resolve, 150));
        }
        
        // Step 5: Results Analysis
        console.log('\nüìä Production Download Simulation Results:');
        console.log(`‚úÖ Successful pages: ${successCount}/${testPages} (${Math.round(successCount/testPages*100)}%)`);
        console.log(`‚ö†Ô∏è  501 Not Implemented: ${error501Count}/${testPages} (${Math.round(error501Count/testPages*100)}%)`);
        console.log(`‚ùå Other errors: ${otherErrorCount}/${testPages} (${Math.round(otherErrorCount/testPages*100)}%)`);
        
        const usablePages = manifest.totalPages - Math.round((error501Count / testPages) * manifest.totalPages);
        console.log(`\nüéØ Estimated usable pages: ~${usablePages}/${manifest.totalPages} (${Math.round(usablePages/manifest.totalPages*100)}%)`);
        
        // Step 6: Production Readiness Assessment
        console.log('\nüöÄ PRODUCTION READINESS ASSESSMENT:');
        
        if (successCount >= testPages * 0.6) {
            console.log('‚úÖ SUCCESS: Florence production download ready');
            console.log('‚úÖ Child page ID routing working correctly');
            console.log('‚úÖ Session management implemented');
            console.log('‚úÖ Size optimization implemented');
            console.log('‚úÖ Page accessibility validated');
            
            if (error501Count > 0) {
                console.log(`‚ö†Ô∏è  NOTE: ${Math.round(error501Count/testPages*100)}% pages have gaps (501 errors)`);
                console.log('üìã RECOMMENDATION: Implement gap filtering in FlorenceLoader');
                console.log('   - Pre-validate page IDs before adding to pageLinks');
                console.log('   - Skip IDs that return 501 Not Implemented');
                console.log('   - Only include accessible pages in final manifest');
            }
            
            return {
                success: true,
                manifest,
                successRate: Math.round(successCount/testPages*100),
                gapRate: Math.round(error501Count/testPages*100),
                needsGapFiltering: error501Count > 0
            };
        } else {
            console.log('‚ùå FAILURE: Too many page access failures');
            console.log(`‚ùå Only ${successCount}/${testPages} pages accessible`);
            console.log('üîß REQUIRES: Additional debugging and fixes');
            
            return {
                success: false,
                error: `Only ${Math.round(successCount/testPages*100)}% pages accessible`
            };
        }
        
    } catch (error) {
        console.error('‚ùå Complete workflow test failed:', error);
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error)
        };
    }
}

testCompleteFlorencdWorkflow().then(result => {
    if (result.success) {
        console.log(`\nüéâ FLORENCE WORKFLOW TEST PASSED`);
        console.log(`Ready for production use with ${result.successRate}% page accessibility`);
        
        if (result.needsGapFiltering) {
            console.log(`\nüìã NEXT STEP: Implement gap filtering to handle ${result.gapRate}% invalid page IDs`);
            process.exit(2); // Exit code 2 = success but needs gap filtering
        } else {
            process.exit(0); // Exit code 0 = complete success
        }
    } else {
        console.log(`\nüí• FLORENCE WORKFLOW TEST FAILED`);
        console.log(`Error: ${result.error}`);
        process.exit(1); // Exit code 1 = failure
    }
}).catch(error => {
    console.error(`\nüí• Test execution failed:`, error);
    process.exit(1);
});